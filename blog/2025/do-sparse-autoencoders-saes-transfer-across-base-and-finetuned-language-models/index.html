<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Do Sparse Autoencoders (SAEs) transfer across base and finetuned language models? | UniReps Blog </title> <meta name="author" content="UniReps Blog"> <meta name="description" content=""> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/blog/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/blog/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/blog/assets/img/unireps_favicon.png?3a42502b41deab62714411b8479222c3"> <link rel="stylesheet" href="/blog/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://unireps-blog.github.io/blog/2025/do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/"> <script src="/blog/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/blog/assets/js/distillpub/template.v2.js"></script> <script src="/blog/assets/js/distillpub/transforms.v2.js"></script> <script src="/blog/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Do Sparse Autoencoders (SAEs) transfer across base and finetuned language models?",
            "description": "",
            "published": "February 06, 2025",
            "authors": [
              
              {
                "author": "Taras Kutsyk",
                "authorURL": "https://www.linkedin.com/in/taras-kutsyk-135006212/",
                "affiliations": [
                  {
                    "name": "University of L'Aquila, L'Aquila",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Tommaso Mencattini",
                "authorURL": "https://www.linkedin.com/in/tommasomencattini/",
                "affiliations": [
                  {
                    "name": "EPFL, Lausanne",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Ciprian Florea",
                "authorURL": "https://www.linkedin.com/in/ciprian-fl/",
                "affiliations": [
                  {
                    "name": "University of Oxford, Oxford",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/blog//"> <span class="font-weight-bold">UniReps</span> Blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/blog/"> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Do Sparse Autoencoders (SAEs) transfer across base and finetuned language models?</h1> <p></p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#1-introduction-and-motivation">1. Introduction and motivation</a> </div> <ul> <li> <a href="#1-1-what-are-saes-and-why-do-we-care-about-them">1.1 What are SAEs and why do we care about them</a> </li> <li> <a href="#1-2-finetuning-models-is-a-challenge-to-ai-safety">1.2 Finetuning models is a challenge to AI safety</a> </li> </ul> <div> <a href="#2-problem-setup">2. Problem setup</a> </div> <ul> <li> <a href="#2-1-studying-default-transferability">2.1 Studying "default" transferability</a> </li> <li> <a href="#2-2-evaluating-saes-performance">2.2 Evaluating SAEs performance</a> </li> </ul> <div> <a href="#3-how-similar-are-residual-activations-of-finetuned-models">3. How similar are residual activations of finetuned models?</a> </div> <div> <a href="#4-how-well-do-the-base-saes-work-on-the-finetuned-models">4. How well do the base SAEs work on the finetuned models?</a> </div> <ul> <li> <a href="#4-1-methodology">4.1 Methodology</a> </li> <li> <a href="#4-2-technical-details">4.2 Technical Details</a> </li> <li> <a href="#4-3-results">4.3 Results</a> </li> </ul> <div> <a href="#5-do-the-base-sae-features-transfer-to-the-finetuned-model">5. Do the base SAE features transfer to the finetuned model?</a> </div> <ul> <li> <a href="#5-1-feature-selection-procedures">5.1 Feature Selection Procedures</a> </li> <li> <a href="#5-2-gemma-2b-features-transferability-test">5.2 Gemma-2b features transferability test</a> </li> <li> <a href="#5-3-mistral-7b-features-transferability-test">5.3 Mistral-7B features transferability test</a> </li> </ul> <div> <a href="#6-conclusions-limitations">6. Conclusions &amp; Limitations</a> </div> <ul> <li> <a href="#6-1-conclusions">6.1 Conclusions</a> </li> <li> <a href="#6-2-limitations">6.2 Limitations</a> </li> </ul> <div> <a href="#appendix">Appendix</a> </div> </nav> </d-contents> <h1 id="tldr-executive-summary"> <strong>TLDR</strong> (Executive Summary)</h1> <ul> <li>We explored <strong>whether Sparse Autoencoders (SAEs)</strong> can effectively transfer from base language models to their finetuned counterparts, focusing on two base models: <a href="https://huggingface.co/google/gemma-2b" rel="external nofollow noopener" target="_blank">Gemma-2b</a> <d-cite key="gemmateam2024gemmaopenmodelsbased"></d-cite> and <a href="https://huggingface.co/mistralai/Mistral-7B-v0.1" rel="external nofollow noopener" target="_blank">Mistral-7B-V0.1</a> <d-cite key="jiang2023mistral7b"></d-cite> (we tested finetuned versions for coding and mathematics respectively)</li> <li>In particular, we split our analysis into three steps: <ol> <li>We analysed the similarity (<strong>Cosine and Euclidian Distance</strong>) of the residual activations, which was <strong>highly correlated with the resulting transferability of the SAEs</strong> for the two models.</li> <li>We computed several performance metrics (L0 Loss, Reconstruction CE Loss, Variance Explained) of the base SAEs on the fine-tuned models. Almost all metrics agreed on a <strong>significant degradation of the SAE performance for the Gemma-2b</strong> model, and <strong>remained within a reasonable range for the Mistral-7B model</strong>, indicating a much better transferability.</li> <li>We took a further step by operationalizing the idea of transferability of SAE from base models to fine-tuned models by applying an <a href="https://transformer-circuits.pub/2023/monosemantic-features#phenomenology-universality" rel="external nofollow noopener" target="_blank">approach from Towards Monosemanticity</a><d-cite key="bricken2023monosemanticity"></d-cite> for studying feature universality through <strong>feature activation similarity</strong> and <strong>feature logit similarity</strong>. These similarity scores were mostly consistent with the results from the previous step, albeit with one caveat for the Gemma-2b model, suggesting that <strong>some SAE features may still transfer</strong> even if the overall SAE performance is poor for the finetuned model.</li> </ol> </li> <li>Overall, our results agree with <a href="https://www.alignmentforum.org/posts/fmwk6qxrpW8d4jvbd/saes-usually-transfer-between-base-and-chat-models" rel="external nofollow noopener" target="_blank">previous work that studied Instruct models</a><d-cite key="sae_finetuning"></d-cite>. That is, SAEs transferability seems to be model-dependent and sensitive to the finetuning process.</li> <li>We make our <a href="https://github.com/tommasomncttn/SAE-Transferability" rel="external nofollow noopener" target="_blank">code repository public</a> to facilitate future work in this direction.</li> </ul> <hr> <h1 id="1-introduction-and-motivation">1. Introduction and motivation</h1> <h2 id="11-what-are-saes-and-why-do-we-care-about-them">1.1 What are SAEs and why do we care about them</h2> <p>We find ourselves in a world where we have machines that speak fluently dozens of languages, can do a wide variety of tasks like programming at a reasonable level, <strong>and we have no idea how they do it!</strong> This is a standard <strong>mechanistic interpretability</strong> (a.k.a. mech interp) pitch - a field that is trying to <strong>express neural networks’ behaviours as human-understandable algorithms</strong>, i.e. <strong>reverse engineer</strong> algorithms learned by a neural network (or a model, in short). The main motivation is that even though we know the exact form of computation being done by the model to transform the input (e.g. text prompt) to the output (e.g. text answer), we don’t know <em>why</em> this computation is doing what it’s doing, and this is a major concern from a standpoint of AI Safety. The model can perform the computation because it’s genuinely trained to perform the task well, or because it learned that doing the task well correlates with its other learned goals like gaining more power and resources. Without understanding the computation, we have no direct way of distinguishing between the two.</p> <p>The solution proposed by mechanistic interpretability is closely analogous to reverse engineering ordinary computer programs from their compiled binaries. In both cases, we have an intrinsically non-interpretable model of computation - a sequence of binary instructions performed on a string of 0s and 1s, and the (mathematical) function of the neural network’s architecture applied with its learned parameters (weights)<d-footnote>This is a pretty important analogy to understand and you can read more about it in [this Anthropic post](https://transformer-circuits.pub/2022/mech-interp-essay/index.html)<d-cite key="Olah_2022"></d-cite> where it's explained better. </d-footnote>. Programmers know that a natural way to think about computer programs is mapping <strong><em>variables</em></strong> into other variables (or new states of existing variables), starting from some pre-initialized state. So, reverse engineering complied binaries boils down to (oversimplifying) identifying binary memory segments that correspond to variables, tracking how these segments change as the program is being executed, coming up with the explanations of the purpose of these variables, and ultimately arriving at the replication of the program source code - a sequence of human-understandable instructions.</p> <p>But what makes us think that the same is possible for neural networks, especially the ones as large as the current Large Language Models (LLMs)? In particular, why should we even expect that neural networks solve tasks similarly to humans, and thus adopt the same “variable-centered” model of computation? While the proof-of-existence for the first question appeared relatively early (see <a href="https://distill.pub/2020/circuits/zoom-in/" rel="external nofollow noopener" target="_blank">Circuits thread by Chris Olah et al.</a><d-cite key="olah2020zoom"></d-cite> for CNNs or a <a href="https://arxiv.org/abs/2301.05217" rel="external nofollow noopener" target="_blank">more recent work by Neel Nanda et al.</a><d-cite key="nanda2023progressmeasuresgrokkingmechanistic"></d-cite> for language models), the second question is a more general claim, and thus requires more general evidence. The first fundamental work that provided such evidence was the <a href="https://transformer-circuits.pub/2023/monosemantic-features" rel="external nofollow noopener" target="_blank">“Towards Monosemanticity” paper by Anthropic</a><d-cite key="bricken2023monosemanticity"></d-cite>, which introduced Sparse Autoencoders (SAEs) for interpreting the language models’ activations. The activations are any intermediate state of the models’ computation, such as residual stream, MLP layers etc. and can be seen as analogous to a program’s memory state. And just as the program’s memory state can be decomposed into variables, the <strong>main purpose of SAEs is to decompose models’ activations into features</strong>.</p> <p>A feature, in general, is a fuzzy term, and you can find some good attempts to define it <a href="https://dynalist.io/d/n2ZWtnoYHrU1s4vnFSAQ519J#z=BQds7CQ8ytq2rolt7p0XQPbt" rel="external nofollow noopener" target="_blank">here</a><d-cite key="nanda_2022"></d-cite>. For this post we’ll use the analogy with variables and link it to a very general definition of a feature as “<em>a</em> <em>property of the input</em>”. The link is pretty natural: <strong>the types and the number of variables a programmer needs to solve a task depends on the task itself</strong> (i.e. on the problem input). So for a model it would seem reasonable if it used different kinds of variables/features depending on its input: you don’t need a feature “this line is inside a for-loop in Python” in a poetry text, or a feature “this word rhymes with ‘sunset’” in the Python code. And given that models have a finite amount of parameters (which limits a total number of variables they can use), we should expect that they will utilize this kind of input-specificity to use as many unique features as they need to perform a specific task.</p> <p>Why are sparse autoencoders called sparse? It’s actually deeply linked with the idea from the previous paragraph: if you want to use many features in a limited activation space (limited by a number of neurons), you have to exploit the fact that <strong>for any input, most of the features will not be there</strong>. So given that modern language models are trained to predict a next token in a huge variety of possible inputs, we should expect that any feature learned by the model will be <strong>sparse</strong>, i.e. it <strong>will be used by the model only for a small fraction of all possible inputs</strong>.</p> <p>But wait, how is it even possible for a model to learn input-specific features if it has a low-dimensional activations space (where dimension equals the number of neurons) but a very high-dimensional input space? The answer is <strong><em>superposition</em></strong> - an idea of exploiting feature sparsity to store more features than dimensions in the activation space. It has a rich mathematical background and we invite an unfamiliar reader to learn more about it in the <a href="https://transformer-circuits.pub/2022/toy_model/index.html" rel="external nofollow noopener" target="_blank">“Toy Models of Superposition” paper by Elhage et al.</a><d-cite key="elhage2022superposition"></d-cite></p> <p>Coming back to SAEs, they were introduced with all of these ideas in mind to <em>solve superposition</em>, i.e. to recover more than <em>n</em> features in an <em>n</em>-dimensional activation space of a model. How are they supposed to do it? The answer is once again in the name - <em>autoencoders</em>, which means that SAEs are neural networks with the “autoencoder” architecture, which is illustrated in a diagram below (borrowed from the great <a href="https://adamkarvonen.github.io/machine_learning/2024/06/11/sae-intuitions.html" rel="external nofollow noopener" target="_blank">Adam Karvonen’s post</a><d-cite key="Karvonen_2024"></d-cite>):</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/sae.png" alt="My Image" width="500"> </div> <p>So the model activations are “encoded” into a high-dimensional vector of feature activations (top right, note that it always has many more elements than the model’s input), and this high-dimensional vector (a.k.a. “code”) is “decoded” back to reconstruct the input, hence the name “autoencoder”. We advise the reader to take a quick look at the <a href="https://transformer-circuits.pub/2023/monosemantic-features#appendix-autoencoder" rel="external nofollow noopener" target="_blank">“Towards monosematicity” appendix</a><d-cite key="bricken2023monosemanticity"></d-cite> where this architecture is presented mathematically<d-footnote>Note that it's different from the diagram in two ways: adding biases vectors **b** and using a transposed encoder/decoder matrix compared to what is seen in the diagram.</d-footnote>, but the core point to understand is that we’re interested in the right part of the above diagram: <strong>how the reconstructed activations are decomposed into a linear combination of feature vectors</strong> from the Decoder matrix (with the weights of a linear combination equal to SAE <em>feature activations</em>, due to how matrix-vector multiplication works). Mathematically, it means that for each input \(x^j\) (which is the model’s activation vector at the place where we ‘attach’ the SAE - residual layer, hidden head activations etc.), we’re looking to express it in the following form:</p> \[\mathbf{x}^j \approx \mathbf{b} + \sum_i f_i(\mathbf{x}^j) \mathbf{d}_i\] <p>where \(f_i(\mathbf{x}) = \text{ReLU}\left( \mathbf{W}_{enc} \mathbf{x} + \mathbf{b}_{enc} \right)_i\) are the feature activations that are computed in the left (“encoder”) part of the diagram, and \(\mathbf{d}_i\) are the rows of the decoder matrix (or columns, if you take the transpose and multiply from the other side). Note that the diagram omits bias vectors \(\mathbf{b}\) for simplicity, but conceptually they don’t change much: instead of decomposing the activation space, we’re decomposing a translation of that space by a fixed vector (because this is just easier for an SAE to learn).</p> <p>If you think about it, it’s exactly what we hoped to do in an analogy with decomposing program memory into variable names! The variables are now features - <strong>vectors (directions) in the activation space</strong>. And <em>if</em> the autoencoder is doing a good job at reconstructing the input, we can expect that this decomposition (and hence the features) to make sense!</p> <p>The last part is tricky though. Unlike variables that are deliberately used by humans to write sensible algorithms, there is no reason to expect that the features we recover with an SAE will be <em>interpretable</em> in a sense that a human can understand on which inputs they activate and can predict their “roles” based on that (e.g. which tokens they help to predict). But this is where the <em>sparsity</em> condition comes in: we don’t only want an SAE to reconstruct the input from a high-dimensional feature-activation representation, <strong>but we also want this representation to be sparse</strong>, i.e. have only a handful of non-zero feature activations at a time. We already touched on the reason for this - the hope is that we’ll be able to recover the “true” features used by the model in this way<d-footnote>It's quite a slippery area to consider the logical relationship between the feature quality of being "truly used" by the model (analogously to correctly recovered variables from the compiled binary) and its interpretability. If the model came up with some genius way to solve a particular task using features no human can comprehend, would they still be considered as interpretable? The answer can vary from "no" to "kind of yes", because it can be argued that humans with their evolutionally developed problem-solving skills can eventually understand (i.e. interpret) how things work, even though it may not be obvious at a first glance. It's also discussed by Neel Nanda [here](https://dynalist.io/d/n2ZWtnoYHrU1s4vnFSAQ519J#z=dzkF4Sh89hg1GUJj5h2TiGVx)<d-cite key="nanda_2022"></d-cite> </d-footnote>. And the way this is achieved is by imposing an L1-loss penalty on the feature activation vector, which intuitively incentivizes the model to not learn any features unless they are really useful in reconstructing the input<d-footnote>There's also a better justified mathematical reason for sparsity, greatly explained [here](http://ufldl.stanford.edu/tutorial/unsupervised/SparseCoding/)<d-cite key="Ng"></d-cite>. Essentially, by learning to decompose the model's activation space into feature activations, we're trying to find an overcomplete basis of feature directions (a basis with more than n vectors in an n-dimensional space), which is impossible to do without imposing some additional criteria. The ["Toy Models of Superposition"](https://transformer-circuits.pub/2022/toy_model/index.html)<d-cite key="elhage2022superposition"></d-cite> is also incredibly helpful to refine one's intuition about this. </d-footnote>.</p> <h3 id="111-sae-features-for-ai-safety">1.1.1 SAE features for AI Safety</h3> <p>The traditional view in mech interp has been that <strong>one cannot interpret the model’s weights if one cannot interpret the neurons that the weights are connecting</strong>. But due to the <a href="https://dynalist.io/d/n2ZWtnoYHrU1s4vnFSAQ519J#z=RDddls6iedarJZiVvLWwnaYI" rel="external nofollow noopener" target="_blank">neurons polysemanticity</a><d-cite key="nanda_2022"></d-cite> (a consequence of superposition), interpreting individual neurons in the language model is extremely hard if at all possible. That’s where SAEs come to the rescue: by revealing the directions in the neuron activation space (i.e. features) that have a clear, interpretable meaning, they allow for a new form of <a href="https://dynalist.io/d/n2ZWtnoYHrU1s4vnFSAQ519J#z=GeeSfnALcakOYfxQcKaAwV6x" rel="external nofollow noopener" target="_blank">circuits</a><d-cite key="nanda_2022"></d-cite> analysis: instead of interpreting weights between neurons, we can instead interpret weights connecting features. Thus the SAE features potentially serve as a new “basis” for circuit analysis, and some of the recent work e.g. by <a href="https://arxiv.org/abs/2403.19647" rel="external nofollow noopener" target="_blank">Marks et al.</a><d-cite key="marks2024sparsefeaturecircuitsdiscovering"></d-cite> and <a href="https://transformer-circuits.pub/2024/march-update/index.html#feature-heads" rel="external nofollow noopener" target="_blank">Batson et al.</a><d-cite key="Batson_Chen_Jones_2024"></d-cite> has already started exploring this idea and producing the first results.</p> <p>So what does this mean for AI Safety? We’ll cite the Anthropic team’s view on this topic (layed out in their <a href="https://transformer-circuits.pub/2023/interpretability-dreams/index.html#safety" rel="external nofollow noopener" target="_blank">“Interpretability Dreams”</a><d-cite key="Olah_2023"></d-cite> post and in the <a href="https://transformer-circuits.pub/2022/toy_model/index.html#strategic" rel="external nofollow noopener" target="_blank">“Strategic Picture” section</a><d-cite key="elhage2022superposition"></d-cite> of the Toy Models paper):</p> <blockquote> <p>We’d like a way to have confidence that models will never do certain behaviors such as “deliberately deceive” or “manipulate.” Today, it’s unclear how one might show this, but we believe a promising tool would be the ability to identify and enumerate over all features.</p> </blockquote> <blockquote> <p>Ultimately we want to say that a model doesn’t implement some class of behaviors. Enumerating over all features makes it easy to say a feature doesn’t exist (e.g. “there is no ‘deceptive behavior’ feature”) but that isn’t quite what we want. We expect models that need to represent the world to represent unsavory behaviors. But it may be possible to build more subtle claims such as “all ‘deceptive behavior’ features do not participate in circuits X, Y and Z.”</p> </blockquote> <p>Summarizing, the hope is to be able to prove statements of the following form:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/eq.png" alt="My Image" width="500"> </div> <h2 id="12-finetuning-models-is-a-challenge-to-ai-safety---saes-to-the-rescue">1.2 Finetuning models is a challenge to AI safety - SAEs to the rescue?</h2> <p>After outlining the procedure behind SAE-interpretability, we can answer a more general question: why is it relevant to translate the matrix language of neural networks (not more understandable to us than binary code) into a human-readable algorithmic language? There are several reasons, but, among the others, once we are able to do so, we can understand what features of an input a model identifies before predicting an answer. This can allow us to identify when a model is learning to deploy features spuriously correlated with the actual labels (an intuitive example <a href="https://ar5iv.labs.arxiv.org/html/1712.02950#:~:text=these%20image%20domains.-,2,Hidden%20Information,-We%20begin%20with" rel="external nofollow noopener" target="_blank">here</a><d-cite key="DBLP:journals/corr/abs-1712-02950"></d-cite>) or when the model is even <a href="https://arxiv.org/abs/2310.06824" rel="external nofollow noopener" target="_blank">lying to us</a><d-cite key="marks2024geometrytruthemergentlinear"></d-cite>. In both of these cases, it is a primary safety concern that these behaviors are not occurring in our model when used in production. Moreover, SAE-interpretability allows us to gain some insight into solving these problems precisely!</p> <p>Nevertheless, reality is often rougher than abstraction, and mechanistic interpretability suffers from one big problem: once we crack the interpretation of a model, we are only able to decode what is going on inside <strong>a singular, particular model, and not all models with the same architecture and different weights</strong>. Luckily, to have a model that shows emergent abilities, <a href="https://epochai.org/blog/compute-trends" rel="external nofollow noopener" target="_blank">we need a lot of compute</a><d-cite key="computetrends"></d-cite>, which remarkably restricts the Pareto frontier of competitive models and therefore the number of pre-trained models that we need to interpret. Therefore, one could think that if we manage to get some good SAE-interpreters for these few, we will be done. This may not be true! While indeed there are few state-of-the-art models, there are tons of finetuned versions of them (<a href="https://twitter.com/ClementDelangue/status/1839375655688884305?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1839375655688884305%7Ctwgr%5Eb537ad0b54dfc2d9ec69e2b01a337c5b0ce9d4e9%7Ctwcon%5Es1_&amp;ref_url=https%3A%2F%2Freadwrite.com%2Fai-startup-hugging-face-reaches-one-million-downloadable-ai-models-thats-a-lot-you-have-never-heard-of%2F" rel="external nofollow noopener" target="_blank">hugging face reached 1 million of models</a>), which are quite cheap to obtain compared to pretraining. <strong>If a simple finetuning will make the model uninterpretable, then we might be in danger</strong>. This could be the case, as <a href="https://arxiv.org/abs/2310.02949" rel="external nofollow noopener" target="_blank">previous studies</a><d-cite key="yang2023shadowalignmenteasesubverting"></d-cite> showed that alignment can be erased with a small finetuning. Then we ask ourselves:</p> <p><em>Is the interpretability of a model as weak as alignment to finetuning?</em></p> <p>In this post, we try to answer these questions and extend the positive results derived from a similar study by <a href="https://www.alignmentforum.org/posts/fmwk6qxrpW8d4jvbd/saes-usually-transfer-between-base-and-chat-models" rel="external nofollow noopener" target="_blank">Kissane et al.</a><d-cite key="sae_finetuning"></d-cite>, where SAEs for the residual stream have been shown to be easily transferable (at the cost of some finetuning).</p> <p>Lastly, we want to remark how this kind of study derives its importance from the weakness of outer alignment forced by some ad-hoc finetuning. Indeed, if interpretability is more resistant to being broken than alignment, the path towards AI safety could be reached via <a href="https://www.cold-takes.com/high-level-hopes-for-ai-alignment/" rel="external nofollow noopener" target="_blank">digital neuroscience</a><d-cite key="Karnofsky_2023"></d-cite>, rather than simply through external finetuning.</p> <hr> <h1 id="2-problem-setup">2. Problem setup</h1> <p>In choosing finetuned models to work with, we tried to strike a balance between the potential relevance of these models (how many people will actually use similar models), and the availability of pre-trained SAEs from the <a href="https://jbloomaus.github.io/SAELens/" rel="external nofollow noopener" target="_blank">SAELens</a><d-cite key="bloom2024saetrainingcodebase"></d-cite> library we used. So, we arrived at the following models and their finetunes:</p> <ol> <li>Gemma-2b (v1) -&gt; <a href="https://huggingface.co/shahdishank/gemma-2b-it-finetune-python-codes" rel="external nofollow noopener" target="_blank">Gemma-2b-it-finetuned-python-codes</a><d-cite key="gemmateam2024gemmaopenmodelsbased"></d-cite> finetune on <strong>Python code</strong> by Dishank Shah.</li> <li>Mistral-7B (v0.1) -&gt; <a href="https://huggingface.co/meta-math/MetaMath-Mistral-7B" rel="external nofollow noopener" target="_blank">MetaMath-Mistral-7B</a><d-cite key="jiang2023mistral7b"></d-cite> finetune on <strong>math problems</strong> by Meta from their <a href="https://arxiv.org/abs/2309.12284" rel="external nofollow noopener" target="_blank">MetaMath paper</a><d-cite key="yu2024metamath"></d-cite> by Yu et al.</li> </ol> <p>We then loaded the following SAEs for these models from SAELens (SAE layer numbering starts from 0):</p> <table style="margin: auto; text-align: center;"> <thead> <tr> <th>Model</th> <th>SAE Release</th> <th>SAE Layer</th> <th>N Features</th> </tr> </thead> <tbody> <tr> <td>Gemma-2b (v1)</td> <td>gemma-2b-res-jb by Joseph Bloom</td> <td>Residual layer #6</td> <td>16384</td> </tr> <tr> <td>Mistral-7B (v0.1)</td> <td>mistral-7b-res-wg by Josh Engels</td> <td>Residual layer #8</td> <td>65536</td> </tr> </tbody> </table> <p>Two important things to note:</p> <ul> <li>Gemma-2b SAE was trained on the <em>base</em> Gemma-2b model, while our Gemma-2b finetune was obtained from the <em>instruct</em> model, so there was one more “finetuning step” compared to the Mistral-7B case.</li> <li>Both finetunes that we used are <em>full</em> finetunes (with respect to the base model), i.e. no layer was frozen during the finetuning process. This is important for our SAE study, because all SAEs would trivially generalize (in terms of their reconstruction quality) if they were applied at the layer where activations are not affected a priori by the finetuning process.</li> </ul> <h2 id="21-studying-default-transferability">2.1 Studying “default” transferability</h2> <p>Similarly to what <a href="https://www.alignmentforum.org/posts/fmwk6qxrpW8d4jvbd/saes-usually-transfer-between-base-and-chat-models" rel="external nofollow noopener" target="_blank">Kissane et al.</a><d-cite key="sae_finetuning"></d-cite> did with the instruct models, we’ll study the SAE transferability “by default”. That is, we’ll take an SAE trained on the base model, and apply it to the finetuned model to see if it maintains its performance (operationalized below). We won’t do any additional finetuning of our SAEs (on the activations from the finetune model), but as the same results from <a href="https://www.alignmentforum.org/posts/fmwk6qxrpW8d4jvbd/saes-usually-transfer-between-base-and-chat-models" rel="external nofollow noopener" target="_blank">Kissane et al.</a><d-cite key="sae_finetuning"></d-cite> indicate: even when SAEs do not transfer by default, they can be finetuned relatively cheaply to recover their performance.</p> <p>Prior to evaluating the SAEs’ performance, we computed different similarity metrics for residual stream activations at the specific layer our SAEs are used for. The goal was to obtain some sort of a prior probability that our SAEs will transfer to the finetune model: the more similar the activations are, the higher is the (expected) probability that our SAEs will transfer. On the one hand, this analysis can be used as a <em>first step to select a fine-tuned model</em> from the thousands available on Hugging-Face. On the other hand, further studies can try to analyze <em>whether the phenomenon of SAE transferability actually correlates with the difference between activations</em> of the base and fine-tuned models (which we treat here only as an unproven heuristic).</p> <h2 id="22-evaluating-saes-performance">2.2 Evaluating SAEs performance</h2> <p>Designing rigorous approaches to evaluate the SAEs’ performance is an open problem in mechanistic interpretability. The main complicating factor is that we’re interested not so much in the SAEs reconstructed output, but rather in <strong>the SAE feature activations and feature vectors</strong>. However, measuring whether the SAEs features are interpretable or whether the features “are truly used by the model” is not straightforward. For our work, we’ll just start with computing standard evaluation metrics proposed either in the original “Towards monosemanticity” paper, or used in the later work, <a href="https://www.lesswrong.com/posts/f9EgfLSurAiqRJySD/open-source-sparse-autoencoders-for-all-residual-stream" rel="external nofollow noopener" target="_blank">e.g. this one by Joseph Bloom</a><d-cite key="jbloom_lesswrong"></d-cite>:</p> <ol> <li> <strong>L0 loss</strong>, namely the number of non-zero values in the feature activations vector. If the features retain their sparsity, we should expect L0 loss to be low compared to the total number of features, with the fraction being usually less than 1% (\(\frac{L_0}{N_{\text{features}}} &lt; 0.01\))</li> <li> <strong>Reconstruction Cross-Entropy (CE) loss</strong> (a.k.a. substitution loss) which is computed as follows: <ol> <li>Run the model up to the layer where we apply the SAE, get this layer’s activations</li> <li>Run the activations through the SAEs, obtaining the reconstructions</li> <li> <strong>Substitute</strong> the original activations with the reconstructed activations, continue the forward pass of the model, and get the corresponding cross-entropy loss</li> </ol> </li> <li> <strong>Variance explained</strong>, is one of the standard ways to measure the difference of original activations and the activations reconstructed by the SAE. Specifically, we’ll use \(R^2\) score a.k.a. <a href="https://en.wikipedia.org/wiki/Coefficient_of_determination" rel="external nofollow noopener" target="_blank">Coefficient of determination</a> </li> <li> <strong>Feature density histograms</strong>: <a href="https://www.lesswrong.com/posts/f9EgfLSurAiqRJySD/open-source-sparse-autoencoders-for-all-residual-stream#Why_can_training_Sparse_AutoEncoders_be_difficult__" rel="external nofollow noopener" target="_blank">as explained by Joseph Bloom</a><d-cite key="jbloom_lesswrong"></d-cite>, ideally the features should be “within good sparsity range”: <strong>not too sparse</strong> (e.g. when the features are “dead” and never activate) and <strong>not too dense</strong> (e.g. activating in more than 10% of the inputs). In both edge cases, anecdotally the features are mostly uninterpretable. One (rather qualitative) way to check this is to plot feature histograms: <ol> <li>Run a given sample of tokens through the model, and get the SAE feature activations.</li> <li>For each feature, record the number of times (tokens) it had a non-zero activation.</li> <li>Divide by the total number of tokens to get the fraction, and take the log10 of it (adding some epsilon value to avoid log-of-zero)</li> <li>Plot the histogram of the resulting log-10 fractions (the number of histogram samples equals to the number of features)</li> </ol> </li> </ol> <p>We’ll compute these metrics first for the base model and its SAE to get a baseline, then for the finetuned model with the same SAE, and compare the resulting metrics against the baseline<d-footnote>Even though density histograms are not technically a metric, we can infer quantitative metrics from them like the number of dead features</d-footnote>. The dataset used in both cases is the original training dataset of the corresponding SAE:</p> <ol> <li> <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb" rel="external nofollow noopener" target="_blank">Fineweb</a><d-cite key="fineweb"></d-cite> dataset for Gemma-2b.</li> <li> <a href="https://huggingface.co/datasets/monology/pile-uncopyrighted" rel="external nofollow noopener" target="_blank">The Pile</a><d-cite key="thepile"></d-cite> dataset for Mistral-7B.</li> </ol> <p>Based on the feature density histograms, we additionally zoomed in on individual features to see how well they transfer using <a href="https://transformer-circuits.pub/2023/monosemantic-features#phenomenology-universality" rel="external nofollow noopener" target="_blank">feature activation similarity and logit weight similarity</a><d-cite key="bricken2023monosemanticity"></d-cite>, as elaborated in the later section of this post.</p> <hr> <h1 id="3-how-similar-are-residual-activations-of-finetuned-models">3. How similar are residual activations of finetuned models?</h1> <p>Before analyzing the SAE metrics on the finetuned models, we will visualize some easier computations on the <strong>residual</strong> activations (at the residual stream of the layer where we apply the corresponding SAE) to get a sense of the SAE transferability. Specifically, we are interested in the similarities between the base and finetuned model activations. We consider two metrics: the Cosine Similarity and the Euclidian Distance, for the model and datasets specified above with the <a href="https://huggingface.co/shahdishank/gemma-2b-it-finetune-python-codes" rel="external nofollow noopener" target="_blank">Gemma-2b Python-codes</a> and <a href="https://huggingface.co/meta-math/MetaMath-Mistral-7B" rel="external nofollow noopener" target="_blank">Mistral-7b MetaMath</a><d-cite key="yu2024metamath"></d-cite> finetunes respectively.</p> <p>Computing the Cosine Similarities and Euclidian Distances of the activations yields a tensor of shape <code class="language-plaintext highlighter-rouge">[N_BATCH, N_CONTEXT]</code> (each token position is determined by its batch number and position in the context). A simple metric to start with is to consider the global mean of the Cosine Similarities of the activations across both batch and context dimensions, giving a single scalar representing the overall similarity. This can be seen in the following table:</p> <table> <thead> <tr> <th>Model/Finetune</th> <th>Global Mean (Cosine) Similarity</th> </tr> </thead> <tbody> <tr> <td>Gemma-2b/Gemma-2b-Python-codes</td> <td>0.6691</td> </tr> <tr> <td>Mistral-7b/Mistral-7b-MetaMath</td> <td>0.9648</td> </tr> </tbody> </table> <p>This already suggests much better transferability of the Mistral-7b SAE for its MetaMath finetune. For a more fine-grained comparison, we flatten the similarities into a <code class="language-plaintext highlighter-rouge">N_BATCH * N_CONTEXT</code> vector and plot the histogram across all tokens:</p> <p>Gemma-2b - Cosine Similarity Histogram</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/3.1.png" alt="My Image" width="700"> </div> <p>Mistral-7b - Cosine Similarity Histogram</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/3.2.png" alt="My Image" width="700"> </div> <p>Gemma-2b - Euclidian Distance Histogram</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/3.3.png" alt="My Image" width="700"> </div> <p>Mistral-7b - Euclidian Distance Histogram</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/3.4.png" alt="My Image" width="700"> </div> <p>We can see how the Cosine Similarities for Mistral-7b are concentrated around a value close to 1, whereas the Gemma-2b similarities are more spread around the mean of 0.66 (higher variance). The Euclidian Distances histogram shows a similar distinction, with the Gemma-2b distances being spread around a mean of around 120, while the bulk of Mistral-7b distances stay at a low value.</p> <p>We also visualize the per-context mean of Cosine Similarities and Euclidian Distances. We compute the mean across batches but preserve the context dimension, giving a tensor of shape <code class="language-plaintext highlighter-rouge">[N_CONTEXT]</code>, which reflects how similarity changes over the context length.</p> <p>Gemma-2b - Cosine Similarity Context Line</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/3.5.png" alt="My Image" width="700"> </div> <p>Mistral-7b - Cosine Similarity Context Line</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/3.6.png" alt="My Image" width="700"> </div> <p>Gemma-2b - Euclidian Distance Context Line</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/3.7.png" alt="My Image" width="700"> </div> <p>Mistral-7b - Euclidian Distance Context Line</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/3.8.png" alt="My Image" width="700"> </div> <p>In the above, we can see how the similarities and distances stabilise quickly after a few tokens of context, albeit around different values. Both models start with close to 1 similarity for the first token, and then stabilize after a few tokens.</p> <p>These results already anticipate a considerable difference in the transferability of the SAEs for the two models, which will be explored more in-depth in the following section.</p> <hr> <h1 id="4-how-well-do-the-base-saes-work-on-the-finetuned-models">4. How well do the base SAEs work on the finetuned models?</h1> <h2 id="41-methodology">4.1 Methodology</h2> <p>In this section, we’ll compute a set of standard SAE metrics for base and finetuned models, using the same base SAE in both scenarios (i.e., the SAE that was trained on the base model activations):</p> <ol> <li>For the <strong>base model</strong>: <ol> <li>we sample input tokens from the <strong>original SAE training dataset</strong> </li> <li>pass the tokens through the base model to get <strong>the model’s activations</strong> </li> <li>pass the activations through the SAE to <strong>get the feature activations</strong> </li> <li>complete the forward pass of the base model to <strong>get the final loss</strong> (used afterward for the reconstructed loss)</li> </ol> </li> <li>Then we repeat the same steps for the <strong>finetuned</strong> <strong>model</strong>, using the same tokens dataset</li> <li>Finally, we compute the metrics mentioned in the Evaluating SAEs performance section.</li> </ol> <h2 id="42-technical-details">4.2 Technical Details</h2> <p>Before delving deeper into the results, we want to point out three technical details:</p> <ol> <li>The sample size used across nearly all experiments is <strong>256K tokens</strong> </li> <li> <p>Similarly to <a href="https://www.alignmentforum.org/posts/fmwk6qxrpW8d4jvbd/saes-usually-transfer-between-base-and-chat-models" rel="external nofollow noopener" target="_blank">Kissane et al.</a><d-cite key="sae_finetuning"></d-cite> we observed a major numerical instability when computing our reconstruction loss and variance explained metrics. As the authors noted:</p> <blockquote> <p>SAEs fail to reconstruct activations from the opposite model that have outlier norms (e.g. BOS tokens). These account for less than 1% of the total activations, but cause cascading errors, so we need to filter these out in much of our analysis.</p> </blockquote> </li> <li> <p>To solve this problem we used a similar outlier filtering technique, where an outlier is defined as <em>an activation vector whose (L2) norm exceeds a given threshold</em>. We tried several ways to find a “good” threshold and arrived at values similar to those used by <em>Kissane et al</em>:</p> <ul> <li> <strong>290 norm value</strong> for the Gemma-2b model</li> <li> <strong>200 norm value</strong> for the Mistral-7B model</li> </ul> <p>Using these threshold values, we found that <strong>only 0.24% activations are classified as outliers in the Gemma-2b model</strong>, and <strong>0.7% in the Mistral-7B</strong>, agreeing with the Kissane et al. result that these outliers account for less than 1% of activations. It should be noticed, however, that we <em>only used this outlier filtering technique for our reconstruction loss &amp; variance explained</em> experiments to avoid numerical errors. In practice, it means that for this experiment the true sample size was a little smaller than for the other experiments, equal to \(\left( 1 - \text{outlier_fraction} \right) \times 256{,}000\) with the \(\text{outlier_fraction}\) defined above.</p> </li> </ol> <h2 id="43-results">4.3 Results</h2> <p>In the following table, we report the results for the first experiment with the <strong>Mistral</strong> model pair:</p> <table style="margin: auto; text-align: center;"> <thead> <tr> <th>Model\\Metric</th> <th>L0 Loss</th> <th>Clean CE Loss</th> <th>Reconstruction CE Loss</th> <th>Loss Delta</th> <th>$$R^2$$ Score (Variance Explained)</th> <th>Dead Features (%)</th> </tr> </thead> <tbody> <tr> <td>Mistral-7B</td> <td>83.37</td> <td>1.78</td> <td>1.93</td> <td><b>0.15</b></td> <td>0.68</td> <td>0.76%</td> </tr> <tr> <td>Mistral-7B MetaMath</td> <td>90.22</td> <td>1.94</td> <td>2.1</td> <td><b>0.16</b></td> <td>0.58</td> <td>0.64%</td> </tr> </tbody> </table> <p>As you can see, the L0-Loss of the features and variance explained increase a bit, but the reconstruction loss delta is almost the same! It suggests that our Mistral SAE may still transfer after finetuning, although with a slightly worse reconstruction quality. Let’s compare these results with the Gemma-2b and its Python finetune:</p> <table style="margin: auto; text-align: center;"> <thead> <tr> <th>Model\\Metric</th> <th>L0 Loss</th> <th>Clean CE Loss</th> <th>Reconstruction CE Loss</th> <th>Loss Delta</th> <th>$$R^2$$ Score (Variance Explained)</th> <th>Dead Features (%)</th> </tr> </thead> <tbody> <tr> <td>Gemma-2b Base</td> <td>53.59</td> <td>2.65</td> <td>3.16</td> <td>0.51</td> <td>0.97</td> <td>48.1%</td> </tr> <tr> <td>Gemma-2b Python-codes</td> <td>84.74</td> <td>3.29</td> <td><b>7.5</b></td> <td><b>4.21</b></td> <td><b>-10.27</b></td> <td>0.1%</td> </tr> </tbody> </table> <p>Now, this is what <em>bad</em> SAE transferability looks like! But actually this should come as no surprise after the <a href="https://www.alignmentforum.org/posts/fmwk6qxrpW8d4jvbd/saes-usually-transfer-between-base-and-chat-models" rel="external nofollow noopener" target="_blank">Kissane et al.</a><d-cite key="sae_finetuning"></d-cite> result: they concluded that Gemma-2b SAEs do not transfer even between the base and the <em>instruct</em> models, so when you add an additional finetuning step on top of the instruct, it’s completely expected that the metrics will get even worse. The authors explain this behavior with an abnormal weights deviation in the instruct model:</p> <blockquote> <p>Here we show that the weights for Gemma v1 2B base vs chat models are unusually different, explaining this phenomenon (credit to Tom Lieberum for finding and sharing this result):</p> </blockquote> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.1.png" alt="My Image" width="700"> </div> <p>But what effect does this have on the SAE features? Well, we could expect that if an SAE is no longer able to reconstruct the input activations, it will always “hallucinate” - any features it “detects” will not make any sense. Let’s see if this expectation holds in practice for the Gemma-2b model.</p> <p>We’ll start with the feature activations histogram plot. In general, this kind of histogram gives little insight since you will always have a large mode at 0 due to feature sparsity, and some kind of log-normal distribution at non-zero activations. Indeed, this is what happens in the base Gemma-2b model, when we plot its log10 feature activations histogram:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.2.png" alt="My Image" width="700"> </div> <p>Two things to note:</p> <ul> <li>The first bar’s count value is <strong>clipped</strong> - it’s much larger than 900k, equal to more than 6 million.</li> <li>We used a smaller sample size for this experiment due to the need to store all the feature activations in memory to plot the histogram - here the sample size is equal to <strong>128K</strong>.</li> </ul> <p>With this in mind, let’s compare it with the same kind of histogram for our Gemma-2b finetune (where the features are given by the same SAE):</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.3.png" alt="My Image" width="700"> </div> <p>If that’s not a characterization for “cursed”, we don’t know what is! Instead of a nice bell curve, we now have some sort of a 3-mode monster in the non-zero activations section. To be clear - nothing like that was present when we repeated this experiment for the Mistral-7B: we obtained the well-expected bell curves with similar mean and standard deviation for both base and finetuned models. We don’t have a good explanation for this Gemma-2b anomaly, but we’ll try to give some deeper insight into what happens with the SAE features in the next section.</p> <p>Let’s move on to the feature densities plot, which was produced as described in the Evaluating SAEs Performance section. Starting from Gemma-2b:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.4.png" alt="My Image" width="700"> </div> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.5.png" alt="My Image" width="700"> </div> <p>As expected from the above results, the two plots have little in common. We see that most of our dead features (in the base model) turn alive in the finetuned one! To see where exactly these dead feature densities land in the finetuned model (what are their new densities), we also made a parallel coordinate plot (below we show two versions of the same plot: with different density ranges highlighted):</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.6.png" alt="My Image" width="700"> </div> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.7.png" alt="My Image" width="700"> </div> <p>So it looks like the dead features spread out quite widely in the finetuned model, contributing to more probability mass before the -3 log-density. As for the dense features (-4 to -1 log density) in the base model, their density interval gets squeezed to (-3, -1) in the finetuned model, causing a sharp mode near the -2.5 log-density value.</p> <p>We’ll continue the Gemma-2b investigation in the next chapter, and conclude this section with the Mistral-7B feature density histograms:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.8.png" alt="My Image" width="700"> </div> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.9.png" alt="My Image" width="700"> </div> <p>We can see that for Mistral the feature densities distribution almost doesn’t change after the model finetuning! The only slight difference is in the number of dead features: the finetuned Mistral has around 80 dead features less than the base one. To zoom in closer, we also show the parallel coordinate plot:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.10.png" alt="My Image" width="700"> </div> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/4.11.png" alt="My Image" width="700"> </div> <p>So yes, a small number of features do turn alive, but also some features (even a smaller amount) turn dead in the finetuned model! Overall though, the feature densities look very similar, with the Pearson correlation of their log10 densities equal to 0.94 (versus 0.47 for the Gemma-2b case).</p> <hr> <h1 id="5-do-the-base-sae-features-transfer-to-the-finetuned-model">5. Do the base SAE features transfer to the finetuned model?</h1> <p>We want to motivate this section with a more thoughtful consideration of the question <strong>what is the best way to operationalize SAE transferability</strong>. In the previous section, we simply checked the standard SAE evaluation metrics to see how well they reconstruct the activations. But this doesn’t necessarily reflect the main goal of using SAEs - <strong>interpreting the model.</strong></p> <p>As noted in the SAE features for AI Safety section of our post, the end goal of using SAEs for interpretability is to be able to <strong>use features as the basis for circuit analysis</strong>. And if we assume that some kind of circuit analysis has been done for the base model to prove that it doesn’t implement certain undesirable behaviors, the most ambitious operationalization of SAE transferability (for AI Safety) would be the ability to apply <strong>the same kind of circuit analysis with the same SAE</strong> (or the finetuned one) <strong>to prove or disprove that the finetuned model is safe.</strong></p> <p>In our case of studying transferability “by default”, the better way to demonstrate it is to show that our SAE features “stay relevant” in the finetuned model, so that we can expect that they still potentially serve as the basis for circuit analysis. Showing this rigorously would be a really difficult task (partly because there’s no standard way to do circuit analysis in the SAE basis yet) and it’s out of scope for this blog post. What we did instead is apply an <a href="https://transformer-circuits.pub/2023/monosemantic-features#phenomenology-universality" rel="external nofollow noopener" target="_blank">approach from Towards Monosemanticity</a><d-cite key="bricken2023monosemanticity"></d-cite> for studying features <strong>universality</strong>:</p> <ul> <li>Normally to study if a feature from model A is conceptually the same (has the same “role” in the model) as another feature in the model B, one can compute <ul> <li> <strong>feature activation similarity</strong>: represent a feature as a vector of its activations across a given sample of tokens, obtaining a <em>feature activations vector →</em> do it for model A’s feature, model B’s feature and compute a <strong>correlation between their activations vectors</strong>.</li> <li> <strong>feature logits similarity:</strong> represent a feature as a vector of its <a href="https://transformer-circuits.pub/2023/monosemantic-features#feature-arabic-effect" rel="external nofollow noopener" target="_blank">logit weights</a><d-cite key="bricken2023monosemanticity"></d-cite> (for each token of the vocab a logit weight is the relative probability of that token as predicted by the feature direct effect), obtaining a <em>feature logit vector→</em> do it for model A’s feature, model B’s feature and compute a <strong>correlation between their logit vectors</strong>.</li> </ul> </li> <li>So, we call model A our base model, model B - the corresponding finetune, and compute feature activation similarity and logits similarity for a given sample of the SAE features (which are the same for the base and finetuned models).</li> </ul> <p>This can be seen as a (very) rough proxy for “the feature is doing the same job in the finetuned model”, and we call it the “<strong>feature transferability test</strong>”.</p> <h2 id="51-feature-selection-procedures">5.1 Feature Selection Procedures</h2> <p>Conceptually, dead features are completely different from the ordinary features: <a href="https://www.lesswrong.com/posts/f9EgfLSurAiqRJySD/open-source-sparse-autoencoders-for-all-residual-stream" rel="external nofollow noopener" target="_blank">as explained by Joseph Bloom</a><d-cite key="jbloom_lesswrong"></d-cite>, they represent permanently lost capacity in an SAE and thus are merely an artifact of the SAE training<d-footnote>Essentially, an SAE is saying “If I cannot find relevant features for reconstructing my input anymore, I’m going to learn a direction(s) in the activation space that is orthogonal to all the inputs I’ve seen, so that I get zero activations for the features I cannot learn and thus I’m no longer penalized by sparsity, at least”. If a feature was dead in the base model but is no longer dead in the finetuned one, it implies a distributional shift in the activation space (for which the SAE was not adapted, but could potentially be adapted by finetuning)</d-footnote>. So we decided to make a separate analysis of dead features and “<strong>regular</strong>” features, that we defined as <strong>features with a log10 density between -5 and -1.</strong></p> <p>By dead features, we mean features that are <strong>exclusively</strong> dead (never activating across our entire 256K sample of tokens), i.e. <strong>dead only in one of the models</strong>:</p> <ul> <li>a “dead base” feature is a feature that is dead in the base model, but not in the finetuned one</li> <li>a “dead finetune” feature is a feature that is dead in the finetuned model, but not in the base one.</li> </ul> <p>We observe that only a handful of features are dead in both models, so we think our definitions give more information on what we’re analysing.</p> <p>Then, our approach for the rest of this section looks as follows:</p> <ol> <li>We sample max 100 exclusively dead features and 1000 regular features using our density histogram values for each base model and its finetune.</li> <li>We convert these features to their activation vector and logit vector representations for both the base model and its finetune.</li> <li>For each regular feature, we compute their <strong>activation similarity</strong> and the <strong>logits similarity</strong> with respect to the corresponding finetune, and for the exclusively dead features - their <strong>activation error:</strong> <ul> <li>We cannot really compute the activation similarity as a correlation score if one of the feature’s activation vectors is constantly 0, i.e. the feature is dead. In this case we take the log10 of these activation vectors (with <code class="language-plaintext highlighter-rouge">1e-10</code> as the epsilon value to avoid a log of zero), take the <a href="https://en.wikipedia.org/wiki/Mean_absolute_error" rel="external nofollow noopener" target="_blank">Mean Absolute Error</a> of the resulting vectors and call it <strong>activation error</strong><d-footnote>It makes little sense to compute dead features logit similarity: if the feature never activates, it doesn’t matter what its logit effect is - it will never manifest itself in the model. </d-footnote>.</li> </ul> </li> <li>Additionally, we plot a <strong>histogram of similarities</strong> for each feature type, since we observed a significant deviation of the similarity score (mainly activation similarity) in some experiments.</li> </ol> <h2 id="52-gemma-2b-features-transferability-test">5.2 Gemma-2b features transferability test</h2> <p>One could say that in the Gemma-2b case, it’s obvious from the previous results that our SAE doesn’t transfer. But we could imagine a case where <em>some</em> (perhaps a tiny fraction) of our SAE features from the regular density interval do still transfer, so we decided to conduct this experiment anyway.</p> <p>Starting with the features that are exclusively dead in the <em>base</em> model, their mean activation error for Gemma-2b and Gemma-2b python-codes finetune is <strong>0.025</strong>. A histogram of these 100 activation errors is given below:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/5.1.png" alt="My Image" width="700"> </div> <p>This made us think that “dead features turning alive” anomaly is not so much of an anomaly, because the dead features activate only (very) slightly in the finetuned model. The max activation value across all 100 dead features in the finetuned model was <strong>1.1,</strong> indicating that our “dead feature direction” is only slightly off in the finetuned model, and can be easily adjusted by SAE finetuning.</p> <p>As for the features that are exclusively dead in the <em>finetune</em> model, Gemma-2b had only two of them on our sample, with the activation error equal to 0.34 and 3.19, which is considerably higher than in the previous case.</p> <p>Moving on to the regular features, we expected to see a much more drastic dissimilarity of their activations. Indeed, the <strong>mean activation similarity for our sample of Gemma-2b regular feature is 0.39</strong>. Let’s check the histogram of these similarity scores:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/5.2.png" alt="My Image" width="700"> </div> <p>Interestingly, we see that a small fraction of features (~10%) have an activation similarity above 0.8! This implies that if these features were interpretable in the base model, they will most likely stay interpretable in the finetune model<d-footnote>We didn’t try to manually interpret these features’ activations to verify this claim, and it would be interesting to see future works in this direction</d-footnote>. But we’re not sure about the significance of this result: this could just as well be noise, so we invite further research in this area.</p> <p>As for the logit similarity of these regular features, it turns out it’s much higher than our activation similarity, with a mean value of <strong>0.952.</strong> Looking at the logit similarity scores histogram, it’s also much more concentrated towards the end of the interval:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/5.3.png" alt="My Image" width="700"> </div> <p>However, it’s easy to be misled by the mean logits similarity score. What it’s really saying is that our unembedding matrix (which is multiplied by the feature direction to get the logits similarity) hasn’t changed that much after finetuning (with a Frobenius norm ratio equal to 1.117 as we checked for our Gemma finetune). So <em>if the feature has still the same direction, we can indeed say that the “direct feature effect” hasn’t changed in the finetuned model, but we never checked this premise!</em> All we know is that there exist ~10% of features which have reasonably high activation similarity scores with the features from the base model. <em>The key point is that the latter is a statement about the feature’s encoder direction</em> (one that is used to project onto to get the feature’s activation, <a href="https://www.lesswrong.com/posts/fKuugaxt2XLTkASkk/open-source-replication-and-commentary-on-anthropic-s" rel="external nofollow noopener" target="_blank">explained by Neel Nanda here</a><d-cite key="Nanda_2023"></d-cite>), <em>not the decoder one -</em> which is what we mean when we talk about <em>feature directions. So it could be the case that the feature is still there but changed its direction</em> as discussed in <a href="https://www.lesswrong.com/posts/bsXPTiAhhwt5nwBW3/do-sparse-autoencoders-saes-transfer-across-base-and?commentId=pJHfoZ2GLD8neS57g" rel="external nofollow noopener" target="_blank">this comment,</a><d-cite key="sae_finetuning"></d-cite> it could also be that some features change their directions and the others don’t - it’s impossible to tell when the reconstruction score (e.g. variance explained) is as poor as in the Gemma-2b case.</p> <h2 id="53-mistral-7b-features-transferability-test">5.3 Mistral-7B features transferability test</h2> <p>Here we repeat all the same experiments for Mistral-7B and its MetaMath finetune, and compare the result with the Gemma-2b case.</p> <p>Let’s start with the features that are exclusively dead in the Mistral base model. Their mean activation error is 0.0003, which is almost <em>two orders of magnitude</em> lower than in the Gemma-2b case. The corresponding histogram looks like this:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/5.4.png" alt="My Image" width="700"> </div> <p>Once again, the results suggest <em>that even though the dead features in the base model are no longer dead in the finetuned one</em>, they activate really weakly on average, so it should be easy to adjust them with a cheap SAE finetuning.</p> <p>The activation error for the features exclusively dead in the finetuned model tells a similar story:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/5.5.png" alt="My Image" width="700"> </div> <p>Here the error is even smaller, implying that even though some features stopped activating after finetuning, their corresponding activation values in the base model were really low. And the features are often uninterpretable in the lowest activation intervals anyway, so it should have a minor overall effect on SAEs transferability.</p> <p>Let’s conclude this section with an analysis of our regular features. As expected from the results of the last section, the activation similarity of these features is quite high, with a mean value of <strong>0.958</strong>. As for the activation scores histogram:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/5.6.png" alt="My Image" width="700"> </div> <p>As we can see, the distribution of the scores is strongly attracted to the 0.9-1.0 correlation interval, so we can conclude that SAE feature transferability is significantly high in this case. This is also backed up by the mean logits similarity of 0.9996, and a rather straightforward logits similarity histogram:</p> <div style="text-align: center;"> <img src="/blog/assets/img/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models/5.7.png" alt="My Image" width="700"> </div> <hr> <h1 id="6-conclusions--limitations">6. Conclusions &amp; Limitations</h1> <h2 id="61-conclusions">6.1 Conclusions</h2> <p>Going back to our original question of <em>“Do SAEs trained on a base model transfer to the finetuned one?”</em>, the most obvious answer that comes to mind now is - it depends! We got drastically different results for our Gemma-2b-python-codes and Mistral-7B-MetaMath finetunes. However, <strong>it seems possible that one could estimate the “degree of transferability” in advance<em>.</em></strong> One method is to compute various weight deviation metrics, such as the one used by <a href="https://www.alignmentforum.org/posts/fmwk6qxrpW8d4jvbd/saes-usually-transfer-between-base-and-chat-models" rel="external nofollow noopener" target="_blank">Kissane et al</a><d-cite key="sae_finetuning"></d-cite> for Gemma-2b, and another method that we used - to compute activation similarities of the model that are fed into an SAE. Both of these anecdotally correlate with the results of our transferability experiments, but a more thorough study is definitely needed.</p> <p>Another takeaway we’ve had after finishing this post is that <strong>“SAE transferability” can mean different things</strong>. One can utilize the standard SAE evaluation metric to get a high-level evaluation of the SAE quality on the finetuned model, but it doesn’t always give a deeper insight into what happens with the SAE feature once we zoom in (which may be more interesting for the real SAE applications in mech interp). Our Gemma-2b results suggest that some SAE features may still be interpretable, even when finetuning has completely rendered the SAE incapable of reconstructing the input. And although the significance of this result can be rightly questioned, we still think it is interesting to investigate further.</p> <h2 id="62-limitations">6.2 Limitations</h2> <p>The main limitations we see in our work are the following:</p> <ul> <li>It’s not clear how our results will generalize to other finetunes. A more principled approach would be to use a custom finetuning setup, where one could e.g. study the relationship between the amount of compute put into finetuning and some key SAE transferability metrics like the reconstruction loss etc. <ul> <li>Our finetuned models also had almost the same dictionaries as the base model (with the exception of a single padding token), so it’s also not clear whether our results generalize to the finetuned model with significantly modified dictionaries (e.g. language finetunes for languages that were not in the original training dataset of the base model)</li> </ul> </li> <li>We only studied SAEs for a single residual layer for Gemma-2b and Mistral-7B models. A more thorough study is needed to see how these results will vary when considering different layers and different SAE activations, e.g. MLP or hidden head activations.</li> <li>All our experiments were performed on the training dataset of the base SAE, i.e. on the original training distribution of the base models. But the finetuned models are mostly used for tasks that they have been finetuned on, so we definitely need some future work here to extend these results to a more specific setting of finetuned models.</li> <li>Our analysis of SAE features transferability was somewhat superfluous, because we didn’t do a thorough investigation of the interpretability of our features after the finetuning. An even more representative study would be to replicate some kind of circuit analysis in the SAE basis to rigorously prove if (at least some) features are still involved in the same computation of the finetuned model.</li> </ul> <hr> <h1 id="appendix">Appendix</h1> <p>All code is available on <a href="https://github.com/tommasomncttn/SAE-Transferability" rel="external nofollow noopener" target="_blank">github</a></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/blog/assets/bibliography/2025-02-06-do-sparse-autoencoders-saes-transfer-across-base-and-finetuned-language-models.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 UniReps Blog. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/blog/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/blog/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>