<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dynamics Animation - Duffing (Evenly-Spaced Streamlines + KE Contours)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    html, body { margin: 0; padding: 0; }
    #graph { width: 100%; height: 500px; }
  </style>
</head>
<body>
  <div id="graph"></div>
  <script>
    // --- Random Gaussian helper (Box-Muller) ---
    function gaussianRandom(mean = 0, std = 1) {
      const u1 = Math.random();
      const u2 = Math.random();
      const z0 = Math.sqrt(-2 * Math.log(Math.max(u1, 1e-12))) * Math.cos(2 * Math.PI * u2);
      return z0 * std + mean;
    }

    // --- Simulation params ---
    const maxPoints = 50;
    const dt = 0.02;
    const lifetime = 10.0;

    const x = [], y = [];
    const pointLifetimes = [];
    const pointAges = [];
    const activePoints = [];
    let nextPointId = 0;
    let time = 0;

    // --- Duffing-like dynamics (x' = y, y' = -y + x - x^3) ---
    function getDynamics(xv, yv) {
      return { dx: yv, dy: -yv + xv - xv * xv * xv };
    }

    // --- "Kinetic energy" proxy: ||(dx,dy)||^2 ---
    function getKineticEnergy(xv, yv) {
      const d = getDynamics(xv, yv);
      return d.dx * d.dx + d.dy * d.dy;
    }

    // --- Grid for contour plot of log10(KE) ---
    function generateKineticEnergyGrid() {
      const resolution = 50;
      const xMin = -3, xMax = 3;
      const yMin = -3, yMax = 3;

      const gx = [], gy = [], gz = [];
      for (let i = 0; i < resolution; i++) gx.push(xMin + (xMax - xMin) * i / (resolution - 1));
      for (let j = 0; j < resolution; j++) gy.push(yMin + (yMax - yMin) * j / (resolution - 1));
      for (let j = 0; j < resolution; j++) {
        const row = [];
        for (let i = 0; i < resolution; i++) {
          const ke = getKineticEnergy(gx[i], gy[j]);
          row.push(Math.log10(Math.max(ke, 1e-10)));
        }
        gz.push(row);
      }
      return { x: gx, y: gy, z: gz };
    }

    // ===== Evenly-Spaced Streamlines =====
    // RK4 for x' = u(x,y), y' = v(x,y)
    function rk4(x, y, h, f) {
      const k1 = f(x, y);
      const k2 = f(x + 0.5*h*k1.u, y + 0.5*h*k1.v);
      const k3 = f(x + 0.5*h*k2.u, y + 0.5*h*k2.v);
      const k4 = f(x + h*k3.u,   y + h*k3.v);
      const u = (k1.u + 2*k2.u + 2*k3.u + k4.u) / 6;
      const v = (k1.v + 2*k2.v + 2*k3.v + k4.v) / 6;
      return { x: x + h*u, y: y + h*v, u, v };
    }

    // small spatial hash for O(1) average proximity checks
    function makeHash(bounds, cell) {
      const {xMin,xMax,yMin,yMax} = bounds;
      const nx = Math.max(1, Math.floor((xMax-xMin)/cell));
      const ny = Math.max(1, Math.floor((yMax-yMin)/cell));
      const buckets = new Map();
      const key = (ix,iy) => ix + ":" + iy;
      const toIdx = (x,y) => ({
        ix: Math.floor((x-xMin)/cell),
        iy: Math.floor((y-yMin)/cell)
      });
      function put(x,y){
        const {ix,iy} = toIdx(x,y);
        if(ix<0||iy<0||ix>=nx||iy>=ny) return;
        const k = key(ix,iy);
        if(!buckets.has(k)) buckets.set(k, []);
        buckets.get(k).push([x,y]);
      }
      function near(x,y,r){
        const {ix,iy} = toIdx(x,y);
        const rad = 1 + Math.ceil(r/cell);
        const rr = r*r;
        for(let dx=-rad; dx<=rad; dx++){
          for(let dy=-rad; dy<=rad; dy++){
            const arr = buckets.get(key(ix+dx, iy+dy));
            if(!arr) continue;
            for(const [px,py] of arr){
              const dx2 = px-x, dy2 = py-y;
              if(dx2*dx2 + dy2*dy2 < rr) return true;
            }
          }
        }
        return false;
      }
      return { put, near };
    }

    // Evenly spaced streamlines (Jobardâ€“Lefer style)
    function createEvenlySpacedStreamlines(getField, bounds, opts = {}) {
      const {
        dSep = 0.22,     // target spacing
        dTest = 0.1,    // stop when within this distance of an existing curve
        step  = 0.04,    // integration step
        maxSteps = 420,  // per direction
        seedGrid = 22,   // coarse seed grid
        minLength = 0.6  // discard short curves
      } = opts;

      const {xMin,xMax,yMin,yMax} = bounds;
      const hash = makeHash(bounds, dSep * 0.5);

      const inBounds = (x,y)=> x>xMin && x<xMax && y>yMin && y<yMax;
      const speed = (u,v)=> Math.hypot(u,v);

      function traceFromSeed(sx,sy) {
        if (hash.near(sx, sy, dTest)) return null;

        // forward
        let xf = sx, yf = sy;
        const fxs = [xf], fys = [yf];
        for (let n=0; n<maxSteps; n++){
          const st = rk4(xf, yf, step, getField);
          xf = st.x; yf = st.y;
          if (!inBounds(xf,yf) || speed(st.u,st.v) < 1e-6 || hash.near(xf,yf,dTest)) break;
          fxs.push(xf); fys.push(yf);
        }

        // backward
        let xb = sx, yb = sy;
        const bxs = [], bys = [];
        for (let n=0; n<maxSteps; n++){
          const st = rk4(xb, yb, -step, getField);
          xb = st.x; yb = st.y;
          if (!inBounds(xb,yb) || speed(st.u,st.v) < 1e-6 || hash.near(xb,yb,dTest)) break;
          bxs.push(xb); bys.push(yb);
        }

        // combine
        bxs.reverse(); bys.reverse();
        const xs = bxs.concat(fxs);
        const ys = bys.concat(fys);

        // length check
        let L = 0;
        for (let i=1;i<xs.length;i++){
          L += Math.hypot(xs[i]-xs[i-1], ys[i]-ys[i-1]);
          if (L > minLength) break;
        }
        if (L < minLength) return null;

        // stamp into hash roughly every dSep/2 along the curve
        let acc = 0, px = xs[0], py = ys[0];
        hash.put(px,py);
        for (let i=1;i<xs.length;i++){
          const qx = xs[i], qy = ys[i];
          acc += Math.hypot(qx-px, qy-py);
          if (acc >= dSep*0.5) { hash.put(qx,qy); acc = 0; }
          px = qx; py = qy;
        }

        return { xs, ys };
      }

      // seeds on a coarse grid; curve grown only if area not covered
      const seeds = [];
      for (let i=0;i<seedGrid;i++){
        const sx = xMin + (xMax-xMin)*(i+0.5)/seedGrid;
        for (let j=0;j<seedGrid;j++){
          const sy = yMin + (yMax-yMin)*(j+0.5)/seedGrid;
          seeds.push([sx,sy]);
        }
      }

      const X = [], Y = [];
      const arrowX = [], arrowY = [], arrowAngles = [];
      
      for (const [sx,sy] of seeds){
        if (hash.near(sx,sy,dSep*0.9)) continue;
        const curve = traceFromSeed(sx,sy);
        if (!curve) continue;
        const {xs,ys} = curve;
        
        // Add line points
        for (let k=0;k<xs.length;k++){ X.push(xs[k]); Y.push(ys[k]); }
        X.push(NaN); Y.push(NaN);
        
        // Add arrows at sparse intervals (every 8th point)
        for (let k=4; k<xs.length-4; k+=8) {
          const x = xs[k], y = ys[k];
          
          // Get the actual velocity field at this point
          const velocity = getField(x, y);
          const angle = Math.atan2(velocity.v, velocity.u) * 180 / Math.PI;
          
          arrowX.push(x);
          arrowY.push(y);
          arrowAngles.push(angle);
        }
      }

      return {
        lineData: {
          x: X,
          y: Y,
          type: 'scatter',
          mode: 'lines',
          line: { width: 1 },
          name: 'Streamlines',
          hoverinfo: 'skip',
          showlegend: true
        },
        arrowData: {
          x: arrowX,
          y: arrowY,
          type: 'scatter',
          mode: 'markers',
          marker: {
            size: 6,
            symbol: 'arrow-up',
            angle: arrowAngles,
            color: 'rgba(0, 0, 0, 0.8)'
          },
          name: 'Flow Direction',
          hoverinfo: 'skip',
          showlegend: false
        }
      };
    }
    // ===== End evenly-spaced streamlines =====

    // --- Seed particles (for your existing animation) ---
    function spawnPoint() {
      const idx = nextPointId++;
      x[idx] = gaussianRandom(0, 1.5);
      y[idx] = gaussianRandom(0, 1.5);
      pointLifetimes[idx] = lifetime;
      pointAges[idx] = 0;
      activePoints.push(idx);
    }
    for (let i = 0; i < maxPoints; i++) spawnPoint();

    // --- Precompute KE grid & z-range ---
    const kineticEnergyData = generateKineticEnergyGrid();
    let zMin = Infinity, zMax = -Infinity;
    for (let j = 0; j < kineticEnergyData.z.length; j++) {
      for (let i = 0; i < kineticEnergyData.z[j].length; i++) {
        const v = kineticEnergyData.z[j][i];
        if (v < zMin) zMin = v;
        if (v > zMax) zMax = v;
      }
    }

    // --- Build evenly-spaced streamlines for the Duffing field ---
    const bounds = { xMin:-3, xMax:3, yMin:-3, yMax:3 };
    function getField(x, y) { const d = getDynamics(x,y); return {u: d.dx, v: d.dy}; }

    const streamlineResult = createEvenlySpacedStreamlines(getField, bounds, {
      dSep: 0.22,   // increase for fewer lines
      dTest: 0.18,
      step: 0.04,
      maxSteps: 420,
      seedGrid: 22,
      minLength: 0.6
    });
    const streamlines = streamlineResult.lineData;
    const arrowheads = streamlineResult.arrowData;

    // --- Plot traces: filled contours, line contours, streamlines, particles ---
    const keContourFilled = {
      x: kineticEnergyData.x,
      y: kineticEnergyData.y,
      z: kineticEnergyData.z,
      type: 'contour',
      colorscale: 'Blues',
      showscale: true,
      name: 'Kinetic Energy (log10)',
      opacity: 0.85,
      zmin: zMin,
      zmax: zMax,
      connectgaps: false,
      ncontours: 10,
      contours: { coloring: 'filled' }
    };

    const keContourLines = {
      x: kineticEnergyData.x,
      y: kineticEnergyData.y,
      z: kineticEnergyData.z,
      type: 'contour',
      colorscale: 'Greys',
      showscale: false,
      name: 'KE contours',
      opacity: 0.6,
      zmin: zMin,
      zmax: zMax,
      ncontours: 10,
      contours: { coloring: 'lines' },
      line: { width: 0.6 }
    };

    const particles = {
      x: x,
      y: y,
      mode: 'markers',
      marker: { size: 4, color: 'rgba(255, 0, 0, 0.7)' },
      name: 'Particles'
    };

    Plotly.newPlot('graph', [keContourFilled, keContourLines, streamlines, arrowheads, particles], {
      xaxis: { range: [-3, 3], title: 'X', zeroline: false },
      yaxis: { range: [-3, 3], title: 'Y', zeroline: false, scaleanchor: 'x', scaleratio: 1 },
      margin: { l: 40, r: 10, t: 40, b: 40 },
      title: 'Duffing Flow: Evenly-Spaced Streamlines + KE Contours',
      showlegend: true
    }, { responsive: true });

    // --- Integrate particles (RK2) and animate ---
    function stepParticles() {
      for (let k = 0; k < activePoints.length; k++) {
        const idx = activePoints[k];

        if (pointAges[idx] >= pointLifetimes[idx]) {
          activePoints.splice(k, 1);
          k--;
          continue;
        }

        const d1 = getDynamics(x[idx], y[idx]);
        const xh = x[idx] + d1.dx * dt * 0.5;
        const yh = y[idx] + d1.dy * dt * 0.5;
        const d2 = getDynamics(xh, yh);

        x[idx] += d2.dx * dt;
        y[idx] += d2.dy * dt;

        pointAges[idx] += dt;
      }
    }

    // Frame rate control
    let lastTime = 0;
    const targetFPS = 30;
    const frameInterval = 1000 / targetFPS;

    function update(currentTime) {
      if (currentTime - lastTime < frameInterval) {
        requestAnimationFrame(update);
        return;
      }
      lastTime = currentTime;

      time += dt;

      while (activePoints.length < maxPoints) spawnPoint();
      stepParticles();

      const activeX = new Array(activePoints.length);
      const activeY = new Array(activePoints.length);
      const colors = new Array(activePoints.length);

      for (let i = 0; i < activePoints.length; i++) {
        const idx = activePoints[i];
        activeX[i] = x[idx];
        activeY[i] = y[idx];
        const ageRatio = pointAges[idx] / pointLifetimes[idx];
        const alpha = Math.max(0.1, 1 - ageRatio);
        colors[i] = `rgba(255, 0, 0, ${alpha})`;
      }

      Plotly.restyle('graph', { x: [activeX], y: [activeY], 'marker.color': [colors] }, [4]); // trace 4 = particles
      requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
  </script>
</body>
</html>
