<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Lorenz Gaussian Animation</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    html, body { margin: 0; padding: 0; }
    #graph { width: 100%; height: 500px; }
  </style>
</head>
<body>
  <div id="graph"></div>
  <script>
    // Box-Muller transform for Gaussian distribution
    function gaussianRandom(mean = 0, std = 1) {
      const u1 = Math.random();
      const u2 = Math.random();
      const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      return z0 * std + mean;
    }

    const maxPoints = 100; // Target number of points to maintain
    const x = [], y = [], z = [];
    const dt = 0.01;
    const lifetime = 2.0; // 2 seconds lifetime
    let time = 0;
    
    // Track point lifetimes
    const pointLifetimes = [];
    const pointAges = [];
    const activePoints = [];
    let nextPointId = 0;

    // Initialize with target number of points
    for (let i = 0; i < maxPoints; i++) {
      spawnPoint();
    }

    function spawnPoint() {
      const idx = nextPointId++;
      
      // Isotropic Gaussian distribution centered at origin
      x[idx] = gaussianRandom(0, 2);
      y[idx] = gaussianRandom(0, 2);
      z[idx] = gaussianRandom(30, 3);
      
      pointLifetimes[idx] = lifetime;
      pointAges[idx] = 0;
      activePoints.push(idx);
    }

    Plotly.newPlot('graph', [{
      x: x,
      y: z,
      mode: 'markers',
      marker: {
        size: 4,
        color: 'rgba(255, 0, 0, 0.6)'
      }
    }], {
      xaxis: {range: [-40, 40], title: 'X'},
      yaxis: {range: [0, 60], title: 'Z'},
      title: 'Lorenz Attractor - Gaussian Initial Conditions'
    }, {responsive: true});

    function compute() {
      const s = 10, b = 8/3, r = 28;
      
      // Update existing points
      for (let i = 0; i < activePoints.length; i++) {
        const idx = activePoints[i];
        if (pointAges[idx] >= pointLifetimes[idx]) {
          // Remove expired point
          activePoints.splice(i, 1);
          i--;
          continue;
        }
        
        // Lorenz equations
        let dx = s * (y[idx] - x[idx]);
        let dy = x[idx] * (r - z[idx]) - y[idx];
        let dz = x[idx] * y[idx] - b * z[idx];

        const xh = x[idx] + dx * dt * 0.5;
        const yh = y[idx] + dy * dt * 0.5;
        const zh = z[idx] + dz * dt * 0.5;

        dx = s * (yh - xh);
        dy = xh * (r - zh) - yh;
        dz = xh * yh - b * zh;

        x[idx] += dx * dt;
        y[idx] += dy * dt;
        z[idx] += dz * dt;
        
        pointAges[idx] += dt;
      }
    }

    function update() {
      time += dt;
      
      // Maintain target number of points
      while (activePoints.length < maxPoints) {
        spawnPoint();
      }
      
      compute();
      
      // Prepare data for plotting (only active points)
      const activeX = [];
      const activeZ = [];
      const colors = [];
      
      for (let i = 0; i < activePoints.length; i++) {
        const idx = activePoints[i];
        activeX.push(x[idx]);
        activeZ.push(z[idx]);
        
        // Color based on age (fade out as they age)
        const ageRatio = pointAges[idx] / pointLifetimes[idx];
        const alpha = Math.max(0.1, 1 - ageRatio);
        colors.push(`rgba(255, 0, 0, ${alpha})`);
      }
      
      Plotly.animate('graph', { 
        data: [{
          x: activeX,
          y: activeZ,
          mode: 'markers',
          marker: {
            size: 4,
            color: colors
          }
        }] 
      }, {
        transition: { duration: 0 },
        frame: { duration: 0, redraw: false }
      });
      
      requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
  </script>
</body>
</html>
