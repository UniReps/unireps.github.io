<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dynamics Animation - Duffing (with ψ Approx Contours)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    html, body { margin: 0; padding: 0; }
    #graph { width: 100%; height: 500px; }
  </style>
</head>
<body>
  <div id="graph"></div>
  <script>
    // --- Random Gaussian helper (Box-Muller) ---
    function gaussianRandom(mean = 0, std = 1) {
      const u1 = Math.random();
      const u2 = Math.random();
      const z0 = Math.sqrt(-2 * Math.log(Math.max(u1, 1e-12))) * Math.cos(2 * Math.PI * u2);
      return z0 * std + mean;
    }

    // --- Simulation params ---
    const maxPoints = 50; // Reduced for better performance
    const dt = 0.02; // Larger time step
    const lifetime = 10.0;

    const x = [], y = [];
    const pointLifetimes = [];
    const pointAges = [];
    const activePoints = [];
    let nextPointId = 0;
    let time = 0;

    // --- Duffing dynamics (x' = y, y' = -y + x - x^3) ---
    function getDynamics(xv, yv) {
      return { dx: yv, dy: -yv + xv - xv * xv * xv };
    }

    // --- Local Koopman eigenfunction approximation ψ_u near (0,0) ---
    // λ_u = (sqrt(5)-1)/2, left eigenvector w_u = ((1+sqrt(5))/2, 1)
    // Cubic coefficients (quadratic terms are zero):
    const SQRT5 = Math.sqrt(5);
    const wx = (1 + SQRT5) / 2;
    const wy = 1;

    const d = (1 - 2 * SQRT5) / 19;
    const e = (27 + 3 * SQRT5) / 38;
    const f = (15 + 27 * SQRT5) / 76;
    const g = (-3 + 6 * SQRT5) / 38;

    function psiApprox(xv, yv) {
      const lin = wx * xv + wy * yv;
      const cubic = d * Math.pow(xv, 3)
                  + e * Math.pow(xv, 2) * yv
                  + f * xv * Math.pow(yv, 2)
                  + g * Math.pow(yv, 3);
      return lin + cubic; // + O(4)
    }

    // --- Grid for contour plot of log10(|ψ|) ---
    function generatePsiGrid() {
      const resolution = 50;
      const xMin = -3, xMax = 3;
      const yMin = -3, yMax = 3;

      const gx = [];
      const gy = [];
      const gz = [];

      for (let i = 0; i < resolution; i++) {
        gx.push(xMin + (xMax - xMin) * i / (resolution - 1));
      }
      for (let j = 0; j < resolution; j++) {
        gy.push(yMin + (yMax - yMin) * j / (resolution - 1));
      }
      const eps = 1e-6; // to avoid log(0)
      for (let j = 0; j < resolution; j++) {
        const row = [];
        for (let i = 0; i < resolution; i++) {
          const psi = psiApprox(gx[i], gy[j]);
          row.push(Math.log10(Math.max(Math.abs(psi), eps)));
        }
        gz.push(row);
      }
      return { x: gx, y: gy, z: gz };
    }

    // --- Seed particles ---
    function spawnPoint() {
      const idx = nextPointId++;
      x[idx] = gaussianRandom(0, 1.5);
      y[idx] = gaussianRandom(0, 1.5);
      pointLifetimes[idx] = lifetime;
      pointAges[idx] = 0;
      activePoints.push(idx);
    }
    for (let i = 0; i < maxPoints; i++) spawnPoint();

    // --- Precompute ψ grid & z-range ---
    const psiData = generatePsiGrid();
    let zMin = Infinity, zMax = -Infinity;
    for (let j = 0; j < psiData.z.length; j++) {
      for (let i = 0; i < psiData.z[j].length; i++) {
        const v = psiData.z[j][i];
        if (v < zMin) zMin = v;
        if (v > zMax) zMax = v;
      }
    }

    // --- Plot traces: filled contours, line contours, particles ---
    const psiContourFilled = {
      x: psiData.x,
      y: psiData.y,
      z: psiData.z,
      type: 'contour',
      colorscale: 'Blues',
      reversescale: false,
      showscale: true,
      name: 'log10(|ψ_u(x,y)|)',
      opacity: 0.85,
      zmin: zMin,
      zmax: zMax,
      connectgaps: false,
      ncontours: 12,
      contours: { coloring: 'filled' }
    };

    const psiContourLines = {
      x: psiData.x,
      y: psiData.y,
      z: psiData.z,
      type: 'contour',
      colorscale: 'Greys',
      showscale: false,
      name: 'ψ_u contours',
      opacity: 0.6,
      zmin: zMin,
      zmax: zMax,
      ncontours: 12,
      contours: { coloring: 'lines' },
      line: { width: 0.6 }
    };

    const particles = {
      x: x,
      y: y,
      mode: 'markers',
      marker: { size: 4, color: 'rgba(255, 0, 0, 0.6)' },
      name: 'Particles'
    };

    Plotly.newPlot(
      'graph',
      [psiContourFilled, psiContourLines, particles],
      {
        xaxis: { range: [-3, 3], title: 'X' },
        yaxis: { range: [-3, 3], title: 'Y' },
        title: 'Duffing: Contours of log10(|ψ_u|) (local Koopman eigenfunction near (0,0))',
        showlegend: true
      },
      { responsive: true }
    );

    // --- Integrate particles (RK2) and animate ---
    function stepParticles() {
      for (let k = 0; k < activePoints.length; k++) {
        const idx = activePoints[k];

        if (pointAges[idx] >= pointLifetimes[idx]) {
          activePoints.splice(k, 1);
          k--;
          continue;
        }

        const d1 = getDynamics(x[idx], y[idx]);
        const xh = x[idx] + d1.dx * dt * 0.5;
        const yh = y[idx] + d1.dy * dt * 0.5;
        const d2 = getDynamics(xh, yh);

        x[idx] += d2.dx * dt;
        y[idx] += d2.dy * dt;

        pointAges[idx] += dt;
      }
    }

    // Frame rate control
    let lastTime = 0;
    const targetFPS = 30;
    const frameInterval = 1000 / targetFPS;

    function update(currentTime) {
      if (currentTime - lastTime < frameInterval) {
        requestAnimationFrame(update);
        return;
      }
      lastTime = currentTime;

      time += dt;

      while (activePoints.length < maxPoints) spawnPoint();

      stepParticles();

      // Pre-allocate arrays
      const activeX = new Array(activePoints.length);
      const activeY = new Array(activePoints.length);
      const colors = new Array(activePoints.length);

      for (let i = 0; i < activePoints.length; i++) {
        const idx = activePoints[i];
        activeX[i] = x[idx];
        activeY[i] = y[idx];
        const ageRatio = pointAges[idx] / pointLifetimes[idx];
        const alpha = Math.max(0.1, 1 - ageRatio);
        colors[i] = `rgba(255, 0, 0, ${alpha})`;
      }

      Plotly.restyle('graph', {
        x: [activeX],
        y: [activeY],
        'marker.color': [colors]
      }, [2]);

      requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
  </script>
</body>
</html>
