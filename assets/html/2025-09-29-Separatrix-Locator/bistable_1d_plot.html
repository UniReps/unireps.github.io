<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bistable 1D Dynamics</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        .container {
            max-width: 500px;
            width: 100%;
        }
        svg {
            display: block;
            width: 100%;
            height: auto;
        }
        .equation-label {
            text-align: center;
            margin-top: 10px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <svg id="plotSvg" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
            <!-- Grid lines -->
            <line x1="50" y1="150" x2="350" y2="150" stroke="#ddd" stroke-width="1"/>
            <line x1="200" y1="30" x2="200" y2="270" stroke="#ddd" stroke-width="1"/>
            
            <!-- Axes -->
            <line x1="50" y1="150" x2="350" y2="150" stroke="#333" stroke-width="2"/>
            <line x1="200" y1="30" x2="200" y2="270" stroke="#333" stroke-width="2"/>
            
            <!-- Axis labels -->
            <foreignObject x="360" y="145" width="30" height="20">
                <div xmlns="http://www.w3.org/1999/xhtml" style="font-size: 14px; color: #333;">
                    \(\psi\)
                </div>
            </foreignObject>
            <foreignObject x="205" y="15" width="30" height="20">
                <div xmlns="http://www.w3.org/1999/xhtml" style="font-size: 14px; color: #333;">
                    \(\dot{\psi}\)
                </div>
            </foreignObject>
            
            <!-- Tick marks and labels on x-axis (will be positioned by JavaScript) -->
            <g id="ticks"></g>
            
            <!-- Plot the function ψ - ψ³ (will be generated by JavaScript) -->
            <path id="functionPath" stroke="#e63946" stroke-width="3" fill="none"/>
            
            <!-- Fixed points (will be positioned by JavaScript) -->
            <g id="fixedPoints"></g>
            
            <!-- Arrows showing flow direction (will be positioned by JavaScript) -->
            <defs>
                <marker id="arrowhead-right" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="0">
                    <polygon points="0 0, 10 3, 0 6" fill="#e63946"/>
                </marker>
                <marker id="arrowhead-left" markerWidth="10" markerHeight="10" refX="1" refY="3" orient="180">
                    <polygon points="0 0, 10 3, 0 6" fill="#e63946"/>
                </marker>
            </defs>
            <g id="arrows"></g>
        </svg>
        <div class="equation-label">
            \(\dot{\psi} = \lambda(\psi - \psi^3)\)
        </div>
    </div>

    <script>
        // Function to compute ψ̇ = ψ - ψ³
        function f(psi) {
            return psi - Math.pow(psi, 3);
        }

        // Coordinate transformation functions
        function xToScreen(psi) {
            // Map ψ from [-2, 2] to screen coordinates [50, 350]
            const psiMin = -2;
            const psiMax = 2;
            const screenMin = 50;
            const screenMax = 350;
            return screenMin + ((psi - psiMin) / (psiMax - psiMin)) * (screenMax - screenMin);
        }

        function yToScreen(psiDot) {
            // Map ψ̇ from [-0.5, 0.5] to screen coordinates [270, 30]
            // Note: inverted because SVG y increases downward
            const psiDotMin = -0.5;
            const psiDotMax = 0.5;
            const screenMin = 270;
            const screenMax = 30;
            return screenMin + ((psiDot - psiDotMin) / (psiDotMax - psiDotMin)) * (screenMax - screenMin);
        }

        // Generate the path for the function
        function generatePath() {
            const numPoints = 200;
            const psiMin = -2;
            const psiMax = 2;
            const step = (psiMax - psiMin) / numPoints;
            
            let pathData = "";
            
            for (let i = 0; i <= numPoints; i++) {
                const psi = psiMin + i * step;
                const psiDot = f(psi);
                
                const x = xToScreen(psi);
                const y = yToScreen(psiDot);
                
                if (i === 0) {
                    pathData += `M ${x} ${y}`;
                } else {
                    pathData += ` L ${x} ${y}`;
                }
            }
            
            return pathData;
        }

        // Generate tick marks at specified positions
        function generateTicks() {
            const ticksGroup = document.getElementById('ticks');
            
            // Define tick positions on x-axis
            const tickPositions = [-1, 1];
            
            tickPositions.forEach(psi => {
                const x = xToScreen(psi);
                
                // Create tick line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', 145);
                line.setAttribute('x2', x);
                line.setAttribute('y2', 155);
                line.setAttribute('stroke', '#333');
                line.setAttribute('stroke-width', '1');
                ticksGroup.appendChild(line);
                
                // Create tick label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x - 5);
                text.setAttribute('y', 170);
                text.setAttribute('font-size', '12');
                text.setAttribute('fill', '#333');
                text.textContent = psi.toString();
                ticksGroup.appendChild(text);
            });
        }

        // Generate fixed points at specified positions
        function generateFixedPoints() {
            const fixedPointsGroup = document.getElementById('fixedPoints');
            
            // Define fixed points: [psi, psiDot, stable]
            // stable: true for filled circle, false for empty circle
            const fixedPointData = [
                [-1, 0, true],   // stable attractor
                [0, 0, false],   // unstable fixed point (separatrix)
                [1, 0, true]     // stable attractor
            ];
            
            fixedPointData.forEach(([psi, psiDot, stable]) => {
                const cx = xToScreen(psi);
                const cy = yToScreen(psiDot);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', stable ? '#2a9d8f' : 'white');
                circle.setAttribute('stroke', '#333');
                circle.setAttribute('stroke-width', '1.5');
                
                fixedPointsGroup.appendChild(circle);
            });
        }

        // Generate arrows at specified positions
        function generateArrows() {
            const arrowsGroup = document.getElementById('arrows');
            const arrowLength = 30; // Length of arrow line in screen pixels
            
            // Define arrows: [psi, psiDot, direction]
            // direction: 'right' or 'left'
            const arrowData = [
                [-2, 0, 'right'],
                [-0.5, 0, 'left'],
                [0.5, 0, 'right'],
                [2, 0, 'left']
            ];
            
            arrowData.forEach(([psi, psiDot, direction]) => {
                const centerX = xToScreen(psi);
                const centerY = yToScreen(psiDot);
                
                let x1, x2;
                if (direction === 'right') {
                    x1 = centerX - arrowLength / 2;
                    x2 = centerX + arrowLength / 2;
                } else {
                    x1 = centerX + arrowLength / 2;
                    x2 = centerX - arrowLength / 2;
                }
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', centerY);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', centerY);
                line.setAttribute('stroke', '#e63946');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('marker-end', `url(#arrowhead-${direction})`);
                
                arrowsGroup.appendChild(line);
            });
        }

        // Set the path data and generate all elements
        document.getElementById('functionPath').setAttribute('d', generatePath());
        generateTicks();
        generateFixedPoints();
        generateArrows();
    </script>
</body>
</html>

